<!doctype html> <html lang=en > <link rel=stylesheet  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/default.min.css"> <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/languages/go.min.js"></script> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/tachyons.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Programming A Guessing Game</title> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <li><a href="https://github.com/overoxidize">GH</a> <li><a href="/menu2/">More gobodies</a> <li><a href="/menu3/">Tags</a> <li><a href="/posts/">Posts</a> </ul> </div> <div id=main > <div class=franklin-content > <h4 id=setting_up_a_new_project ><a href="#setting_up_a_new_project" class=header-anchor >Setting Up A New Project:</a></h4> <p>To generate a new Rust project use the following command: </p> <p><code>cargo new &lt;project-name&gt;</code>.</p> <h3 id=new_rust_projects_will_have_a_minimal_cargoa_hreftoms_ordinary_markup_languagetoml_file ><a href="#new_rust_projects_will_have_a_minimal_cargoa_hreftoms_ordinary_markup_languagetoml_file" class=header-anchor >New Rust projects will have a minimal Cargo.<a href="&#91;&#91;Toms Ordinary Markup Language">toml</a> file.</a></h3> <h3 id=cargotoml ><a href="#cargotoml" class=header-anchor >Cargo.toml:</a></h3> <pre><code class="Rust hljs">[package]
name = <span class=hljs-string >&quot;guessing_game&quot;</span>
version = <span class=hljs-string >&quot;0.1.0&quot;</span>
authors = [<span class=hljs-string >&quot;Your Name &lt;you@example.com&gt;&quot;</span>]
edition = <span class=hljs-string >&quot;2018&quot;</span>

[dependencies]</code></pre> <h4 id=processing_a_guess ><a href="#processing_a_guess" class=header-anchor >Processing A Guess:</a></h4> <pre><code class="Rust hljs"><span class=hljs-keyword >use</span> std::io;

<span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;Guess the number!&quot;</span>);

    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;Please input your guess.&quot;</span>);

    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >guess</span> = <span class=hljs-type >String</span>::<span class="hljs-title function_ invoke__">new</span>();

    io::<span class="hljs-title function_ invoke__">stdin</span>()
        .<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class=hljs-keyword >mut</span> guess)
        .<span class="hljs-title function_ invoke__">expect</span>(<span class=hljs-string >&quot;Failed to read line&quot;</span>);

    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;You guessed: {}&quot;</span>, guess);
}</code></pre> <p>By default, Rust will bring only a few types into scope in the prelude, so if you want a type that isn&#39;t available in the prelude, you have to add it yourself, with the <code>use &lt;type&gt;</code> statement.</p> <h2 id=storing_values_with_variables ><a href="#storing_values_with_variables" class=header-anchor >Storing Values with Variables:</a></h2> <code>let mut guess &#61; String::new&#40;&#41;;</code> <p><strong>A mutable variable guess bound to a new empty instance of String.</strong></p> <p>You can declare a variable with the <code>let</code> keyword, and make it mutable with the <code>mut</code> keyword.</p> <p>The <code>::new&#40;&#41;</code> syntax indicates that an associated function that exists on a type is being called. <code>new</code> exists on mosts types, for creating new values of certain times.</p> <h4 id=receiving_input ><a href="#receiving_input" class=header-anchor >Receiving Input</a></h4> <p>Using std::io allows us to access code from the module that allows us to deal with input an output, and it provides the Read and Write traits, which can be implemented in other types.</p> <p>The <code>read_line&#40;&amp;mut guess&#41;</code> line helps us read the input from out terminal, the stdin, and it allows us to store that input in our mutable variable, which we indicate is a reference to a mutable variable with the <code>&amp;mut</code> syntax.</p> <p>References in Rust are perhaps similar but not exactly like references in the context of &#39;pass by reference&#39;, but they allow multiple parts of code to access a datum without copying it into memory each time.</p> <p>The <code>read_line</code> function returns a value, of the type io::Result.</p> <p><strong><strong>Result</strong></strong> types are <strong>enums</strong>, meaning they can be one of a discrete, finite set of values, which are referred to as <strong>variants</strong>.</p> <p>The <code>Result</code> variants, are <code>Ok</code>, and <code>Err</code>.</p> <p><code>Ok</code>, indicates the operation was successful, <code>Err</code> contains information on how/why it wasn&#39;t.</p> <p>Instances of <code>Result</code> have <code>expect</code> methods that can be called, causing the program to crash and display your message.</p> <p>If the value is <code>Ok</code>, <code>expect</code> will simply return it to you.</p> <h4 id=using_crates_to_get_more_functionality ><a href="#using_crates_to_get_more_functionality" class=header-anchor >Using Crates to Get More Functionality:</a></h4> <p>Crates are collections of Rust source, and this project is a <strong>binary</strong> crate, intended to be an executable, but there are also library crates, such as <code>rand</code>, which are intended to be used in building binary crates.</p> <p>Crates such as these, are added to the Cargo.toml file as dependencies.</p> <p>Rust handles versioning of project dependencies with semver.</p> <p>Most crates in the Rust ecosystem are stored in Crates.io, the registry for libraries.</p> <p>Cargo will not only grab your dependencies, but any required upstream dependencies that those depend on as well.</p> <p>The <strong><strong>Cargo.lock</strong></strong> file is for producing builds that can run on other computers, even if changes in the dependencies take places, and are on a new SemVer than the ones your project depends on.</p> <p><code>cargo update</code> will update all of the out of date dependencies in your Cargo.toml file, but </p> <h4 id=comparing_guesses ><a href="#comparing_guesses" class=header-anchor >Comparing Guesses:</a></h4> <pre><code class="Rust hljs"><span class=hljs-keyword >use</span> rand::Rng;
<span class=hljs-keyword >use</span> std::cmp::Ordering;
<span class=hljs-keyword >use</span> std::io;

<span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
    <span class=hljs-comment >// --snip--</span>

    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;You guessed: {}&quot;</span>, guess);

    <span class=hljs-keyword >match</span> guess.<span class="hljs-title function_ invoke__">cmp</span>(&amp;secret_number) {
        Ordering::Less =&gt; <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;Too small!&quot;</span>),
        Ordering::Greater =&gt; <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;Too big!&quot;</span>),
        Ordering::Equal =&gt; <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;You win!&quot;</span>),
    }
}</code></pre> <p>In this code, we use the :: syntax to bring types outside of the scope of the prelude into local scope for use.</p> <p><code>Ordering</code>, is an enum, meaning it &quot;contains&quot; several variants, &#40;more technically, can be of the type of one of several variants&#41;, which are <code>Greater</code>, <code>Less</code>, and <code>Equal</code>.</p> <p>Here the <code>cmp</code> method will compare the value it&#39;s given, with the value it was called on, and will return one of the <code>Ordering</code> variant types, which match will then compare with the arm&#39;s of it&#39;s body.</p> <p><code>match</code> : the arms consist of patterns and the code to be executed upon a match between a pattern and a value.</p> <p>While Rust does have a strong static type system, it also has type inference, for instance, we didn&#39;t have to indicate guess was a string.</p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Septimia Zenobia. Last modified: March 18, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>