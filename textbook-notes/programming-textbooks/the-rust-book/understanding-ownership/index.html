<!doctype html> <html lang=en > <link rel=stylesheet  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/default.min.css"> <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/languages/go.min.js"></script> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/tachyons.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Understanding Ownership</title> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <li><a href="https://github.com/overoxidize">GH</a> <li><a href="/posts/">Posts</a> </ul> </div> <div id=main > <div class=franklin-content > <h1 id=ownership_is_a_feature_unique_to_rust_enabling_memory_safety_without_a_garbage_collector ><a href="#ownership_is_a_feature_unique_to_rust_enabling_memory_safety_without_a_garbage_collector" class=header-anchor >Ownership is a feature unique to rust, enabling memory safety, without a garbage collector.</a></h1> <h1 id=what_is_ownership ><a href="#what_is_ownership" class=header-anchor ><strong>What Is Ownership?</strong></a></h1> <h2 id=all_programs_must_manage_the_way_they_use_a_computers_memory_while_running ><a href="#all_programs_must_manage_the_way_they_use_a_computers_memory_while_running" class=header-anchor >All programs must manage the way they use a computers memory while running.</a></h2> <h2 id=some_languages_use_a_a_hrefgarbage_collectiongc_or_garbage_collector_a_garbage_collector_automatically_frees_up_memory_that_a_program_isnt_using_anymore_whereas_other_languages_require_you_to_explicitly_manage_the_memory_your_program_will_use ><a href="#some_languages_use_a_a_hrefgarbage_collectiongc_or_garbage_collector_a_garbage_collector_automatically_frees_up_memory_that_a_program_isnt_using_anymore_whereas_other_languages_require_you_to_explicitly_manage_the_memory_your_program_will_use" class=header-anchor >Some languages use a <a href="&#91;&#91;**Garbage Collection**&#93;&#93;">GC</a>, or garbage collector: A <strong>garbage collector</strong> automatically frees up memory that a program isn&#39;t using anymore., whereas other languages require you to explicitly manage the memory your program will use.</a></h2> <h2 id=rust_takes_a_different_approach-_memory_is_managed_via_an_ownership_system_with_a_set_of_rules_the_compiler_checks_at_compile_time ><a href="#rust_takes_a_different_approach-_memory_is_managed_via_an_ownership_system_with_a_set_of_rules_the_compiler_checks_at_compile_time" class=header-anchor >Rust takes a different approach- memory is managed via an ownership system, with a set of rules the compiler checks at compile time.</a></h2> <h3 id=the_stack_and_the_heap ><a href="#the_stack_and_the_heap" class=header-anchor ><strong>The Stack and The Heap</strong></a></h3> <p>In a language like Rust, whether a value is on the stack or #heap, has a more direct effect on how the code behaves, and your decision making.</p> <p>Both the stack and the heap are parts of memory that are available to your code at runtime, but they&#39;re structured differently.</p> <p>The stack stores values in the order it receives them, and returns them in the opposite order, in a #LIFO manner.</p> <p>You push data <strong>onto</strong> the #stack, and pop data <strong>off</strong> of the stack.</p> <p>All data on the stack must have a known, fixed size, meaning if the size is unknown at runtime, or might change during runtime, it must be stored on the #heap.</p> <p>A #heap is less organized: when you put data on the heap, the operating system places that data in a random spot that is big enough to store it, and returns a pointer to that location. This is usually referred to as <strong>allocation</strong>, because you are implicitly allocating an amount of memory for storing data.</p> <p>Pushing to the stack is faster, because the OS knows where to put it: wherever the stack is stored. Allocating heap space requires more work, because the OS has to <strong>find</strong> that space. Contemporary processors may be faster if they jump around less in memory &#40;&#40;&#40;Xigdv5YRN&#41;&#41; This is because <strong>Computers are tuned to get an extra speed boost when reading memory addresses that&#39;re close to each other</strong>. &#41; &#40;See &#91;&#91;RAM&#93;&#93;&#41;. Even though the memory controller can jump between far-apart memory addresses quickly, programs <strong>tend to</strong> access memory that&#39;s nearby. Thusly, the stack is usually quicker.</p> <p>Keeping track of what parts of your code use stack vs heap space, deduping heap data, and more, are all problems that ownership addresses.</p> <h3 id=ownership_rules ><a href="#ownership_rules" class=header-anchor ><strong>Ownership Rules:</strong></a></h3> <p>Each value in Rust has a variable that&#39;s called its owner.</p> <p>There can only be one owner at a time.</p> <p>When the owner goes out of scope, the value will be dropped.</p> <h2 id=variable_scope ><a href="#variable_scope" class=header-anchor ><strong>Variable Scope</strong></a></h2> <p>A scope is the area within a program in which a variable is valid.</p> <pre><code class="Rust hljs"><span class=hljs-meta >#![allow(unused_variables)]</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
<span class=hljs-keyword >let</span> <span class=hljs-variable >s</span> = <span class=hljs-string >&quot;hello&quot;</span>;
}</code></pre> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
    {<span class=hljs-comment >// s is not valid here, it’s not yet declared</span>
        <span class=hljs-keyword >let</span> <span class=hljs-variable >s</span> = <span class=hljs-string >&quot;hello&quot;</span>;<span class=hljs-comment >// s is now valid</span>

        <span class=hljs-comment >// do stuff with s</span>
    }<span class=hljs-comment >// this scope is over, s is no longer valid</span>
}</code></pre> <p>In other words, there are two points in a variables existence: when it comes into scope &#40;becomes valid&#41;, and when it goes out of scope &#40;becomes invalid&#41;.</p> <p><strong>The String Type</strong></p> <p>Rust has a <code>str</code> type in the core language, and a <code>String</code> type, provided in the standard library, which is a string <strong>literal</strong>.</p> <p>String literals aren&#39;t suitable for every situation that requires text- they&#39;re immutable. Also, every possible string value can&#39;t be known before hand, if you think about things like user input.</p> <p>In these situation, <code>String</code>, is used, and is allocated on the heap, allowing us to store a non-deterministic amount of text, that can be unknown at compile time.</p> <p>You can create a <code>String</code> from a <code>str</code> using <code>String::from&#40;str&#41;</code>, and the double colon allows us to namespace a function, in this case from, &#40;to use without collisions with other functions named <strong>from</strong>&#41;.</p> <p>Via <code>String::from&#40;&#41;</code>, we request the required memory from the memory allocator.</p> <p>These kinds of strings can be mutated.</p> <p>The difference is how these two types deal with memory- string literals have a known size at compile time, and thus can be stored on the stack, but when we don&#39;t, we have to store on the heap, in order to allocate memory dynamically.</p> <p>There&#39;s a natural point at which the memory allocated for String can be returned- when the variable that owns the value goes out of scope. When this takes place, Rust calls an internal function, <code>drop</code>, for us, and this performs the job of C&#39;s <code>free</code>, which is done with <a href="&#91;&#91;**Garbage Collection**&#93;&#93;">#GC</a>.</p> <h2 id=ways_variables_data_interact_move ><a href="#ways_variables_data_interact_move" class=header-anchor ><strong>Ways Variables &amp; Data Interact: Move</strong></a></h2> <pre><code class="Rust hljs"><span class=hljs-keyword >let</span> <span class=hljs-variable >x</span> = <span class=hljs-number >5</span>;
<span class=hljs-keyword >let</span> <span class=hljs-variable >y</span> = x;</code></pre> <p>The value 5 is bound to x, and the value x is bound to y.</p> <p>&#40;Note that both instances of the value 5 are pushed onto the stack here&#41;. The value is <strong>copied</strong>.</p> <p><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs&#37;2Fapp&#37;2F0xLEDEV-HQ&#37;2FeRq4v8tcs8.png?alt&#61;media&amp;token&#61;1767054e-dc8e-4a5f-a786-a355ab5d64f6" alt="" /></p> <h2 id=now_lets_look_at_the_string_version ><a href="#now_lets_look_at_the_string_version" class=header-anchor >Now, let&#39;s look at the <code>String</code> version:</a></h2> <pre><code class="Rust hljs"><span class=hljs-keyword >let</span> <span class=hljs-variable >s1</span> = <span class=hljs-type >String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class=hljs-string >&quot;hello&quot;</span>);
<span class=hljs-keyword >let</span> <span class=hljs-variable >s2</span> - s1;</code></pre> <h2 id=while_this_code_looks_similar_to_the_code_above_they_dont_operate_in_the_same_way_memory_wise ><a href="#while_this_code_looks_similar_to_the_code_above_they_dont_operate_in_the_same_way_memory_wise" class=header-anchor >While this code looks similar to the code above, they don&#39;t operate in the same way, memory wise.</a></h2> <p>A <code>String</code> is composed of a pointer to the memory holding the contents of the string, a length, and a capacity. The length is the number of bytes required to store the string. When we assigned s1 to s2, the <code>String</code> data is copied &#40;length, and capacity&#41;, but not the data on the heap &#40;differing between <code>String</code><strong>data</strong> &amp; <code>String</code><strong>content</strong>&#41;.</p> <p><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs&#37;2Fapp&#37;2F0xLEDEV-HQ&#37;2Fxfs3sFkdxu.png?alt&#61;media&amp;token&#61;112da031-5c82-4420-8a9e-ede0ec2655fb" alt="" /></p> <p>Part of the reason for this is that the copying operation could become expensive or unperformant depending on the size of the data on the heap.</p> <p>However, we&#39;re now faced with a problem:</p> <p>When a variable goes out of scope, Rust calls <code>drop</code> and, and cleans up the memory for that variable. In the case of s1 &amp; s2, they both go out of scope simultaneously, and thus would end up trying to free the same piece of memory, resulting in a <code>double free</code> error.</p> <p>To combat this, Rust simply invalidates s1, thus removing the need to free anything when it goes out of scope.</p> <p>Rusts invalidation of s1, while keeping s2 valid, is called a <strong>move</strong>, in that the data in s1 was moved into s2.</p> <p>Rust will never automatically create deep copies of data.</p> <h2 id=ways_variables_data_interact_clone ><a href="#ways_variables_data_interact_clone" class=header-anchor ><strong>Ways Variables &amp; Data Interact: Clone</strong></a></h2> <p>If we do want to deeply copy heap data, we can use <code>clone</code>.</p> <h2 id=stack-only_data_copy ><a href="#stack-only_data_copy" class=header-anchor ><strong>Stack-Only Data: Copy</strong></a></h2> <pre><code class="Rust hljs"><span class=hljs-keyword >let</span> <span class=hljs-variable >x</span> = <span class=hljs-number >5</span>;
<span class=hljs-keyword >let</span> <span class=hljs-variable >y</span> = x;
<span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;X is: {}, y is: {}&quot;</span>, x,y);</code></pre> <p>While it seems contradictory, that we don&#39;t have to call clone, thre is a reason.</p> <p>Integer types have a size that is known at compile time, so they are stored entirely on the stack, and thus copies are easy to make. </p> <p>Rust provides a special annotation called the <code>Copy</code> trait, that we can place on integers on the stack. If a type has the <code>Copy</code> trait, an older variable may still be useable after assignment.</p> <p>We can&#39;t annotate a type with <code>Copy</code> if the type, or any of its sub-types have implemented the Drop trait.</p> <p>Generally, any scalar values are copy &#40;or groupings&#41;, as well as anything that doesn&#39;t need to be allocated on the heap.</p> <h2 id=ownership_and_functions ><a href="#ownership_and_functions" class=header-anchor ><strong>Ownership and Functions</strong></a></h2> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
	<span class=hljs-keyword >let</span> <span class=hljs-variable >s</span> = <span class=hljs-type >String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class=hljs-string >&quot;hello&quot;</span>); <span class=hljs-comment >// s in scope</span>
	
  	<span class="hljs-title function_ invoke__">takes_ownership</span>(s); <span class=hljs-comment >// s moved into function</span>
  	<span class=hljs-comment >// s is no longer valid</span>
    <span class=hljs-comment >// if we tried to use s here, we&#x27;d get a </span>
    <span class=hljs-comment >// compile-time error.</span>
    <span class=hljs-keyword >let</span> <span class=hljs-variable >x</span> = <span class=hljs-number >5</span>; <span class=hljs-comment >// x is in scope</span>
  
    <span class="hljs-title function_ invoke__">makes_copy</span>(x); <span class=hljs-comment >// x *would* move into function</span>
  	<span class=hljs-comment >// but integers are copy, so x remains valid.</span>
  
}<span class=hljs-comment >// now x goes out of scope, then s, but since s&#x27;</span>
 <span class=hljs-comment >// value was moved, nothing special happens.</span>

<span class=hljs-keyword >fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class=hljs-type >String</span>) { <span class=hljs-comment >// some_string in scope</span>
  <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;{}&quot;</span>, some_string);
} <span class=hljs-comment >// some string goes out of scope and drop is called.</span>
 <span class=hljs-comment >// The memory is now freed.</span>

<span class=hljs-keyword >fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class=hljs-type >i32</span>) {
  <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;{}&quot;</span>, some_integer);
} <span class=hljs-comment >// some integer leaves scope, but nothing happens</span>
 <span class=hljs-comment >// because copy.</span></code></pre> <h2 id=return_values_and_scope ><a href="#return_values_and_scope" class=header-anchor ><strong>Return Values and Scope</strong></a></h2> <p>The semantic for passing a value are similar to those for assigning values to variables. Passing a variable will move or copy &#40;data&#41; just as assignment does.</p> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
	<span class=hljs-keyword >let</span> <span class=hljs-variable >s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();
    <span class=hljs-comment >// gives_ownership moves it&#x27;s return value</span>
    <span class=hljs-comment >// into s1</span>
	<span class=hljs-keyword >let</span> <span class=hljs-variable >s2</span> = <span class=hljs-type >String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class=hljs-string >&quot;hello&quot;</span>); <span class=hljs-comment >// s2 in scope</span>
    <span class=hljs-comment >// s2 is moved into takes_and_gives_back</span>
    <span class=hljs-comment >// which moves it&#x27;s value into s3</span>
    <span class=hljs-keyword >let</span> <span class=hljs-variable >s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);
} <span class=hljs-comment >// Here, s3 goes out of scope, and is dropped</span>
  <span class=hljs-comment >// while s2 remains untouched because it&#x27;s value was moved.</span>
  <span class=hljs-comment >// was moved.</span>
  <span class=hljs-comment >//</span>

<span class=hljs-keyword >fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >String</span> { 
  <span class=hljs-comment >// gives_ownership will move it&#x27;s return value</span>
  <span class=hljs-comment >// into the function that calls it.</span>
	<span class=hljs-keyword >let</span> <span class=hljs-variable >some_string</span> = <span class=hljs-type >String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class=hljs-string >&quot;hello&quot;</span>); <span class=hljs-comment >// some string in scope</span>
  
    some_string <span class=hljs-comment >// returned to calling function.</span>
}

<span class=hljs-keyword >fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class=hljs-type >String</span>) <span class=hljs-punctuation >-&gt;</span> {
	a_string
 }</code></pre> <p>The ownership of a variable follows a pattern: assigning a value to another variable moves it. When a variable includes data on the heap, and goes out of scope, the value will be cleaned up my drop &#40;the allocated memory returned to the memory allocator&#41;.</p> <p>Taking ownership with every function is tedious, so there are ways to let a function use a borrow without owning it. Basically, <strong>borrowing</strong>.</p> <p><strong>References and Borrowing</strong></p> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
    <span class=hljs-keyword >let</span> <span class=hljs-variable >s1</span> = <span class=hljs-type >String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class=hljs-string >&quot;hello&quot;</span>);

    <span class=hljs-keyword >let</span> (s2, len) = <span class="hljs-title function_ invoke__">calculate_length</span>(s1);

    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;The length of &#x27;{}&#x27; is {}.&quot;</span>, s2, len);
}

<span class=hljs-keyword >fn</span> <span class="hljs-title function_">calculate_length</span>(s: <span class=hljs-type >String</span>) <span class=hljs-punctuation >-&gt;</span> (<span class=hljs-type >String</span>, <span class=hljs-type >usize</span>) {
    <span class=hljs-keyword >let</span> <span class=hljs-variable >length</span> = s.<span class="hljs-title function_ invoke__">len</span>(); <span class=hljs-comment >// len() returns the length of a String</span>

    (s, length)
}</code></pre> <p>The issue with this code, is that this process of returning multiple values that are owned elsewhere, is tedious. There&#39;s an easier way, which is to use <code>&amp;</code>, which indicates a reference to an object. As using <code>&amp;</code> creates a reference, we necessarily need a method for <strong>dereferencing</strong> objects, which comes from the trusty <code>*</code>, given to us from C. The <code>&amp;</code> syntax also effects the return signature of a function, as well as the parameter type. Borrowed values are not mutable, by default, but mutable references can be created by appending the ampersand and mut keyword, <code>&amp;mut</code>.</p> <p>The catch, or tradeoff here, is that a piece of data can only have one mutable reference per scope. This allows for a strict, but controlled mutation, which prevents a data race.</p> <p>A <a href="&#91;&#91;Data Race&#93;&#93;">#data-race</a> is a type of race condition that occurs when:</p> <ol> <li><p>Two or more pointers access the same data simultaneously.</p> <li><p>At least one of the pointers is writing data.</p> <li><p>There&#39;s no mechanism for synchronizing access.</p> </ol> <p>Data races cause undefined behavior, and can be difficult to diagnose and fix during runtime.</p> <p>We can use curly brackets to initiate a new scope, allowing for <strong>multiple references, as opposed to simultaneous ones.</strong></p> <p>There is a similar rule, which is that you can&#39;t have mutable and immutable references to the same piece of data.</p> <p>Though this <strong>may</strong> be possible via creating a new scope&#40;?&#41;.</p> <p>Update: it is.</p> <h1 id=the_slice_type ><a href="#the_slice_type" class=header-anchor ><strong>The Slice Type</strong></a></h1> <h2 id=another_data_type_that_doesnt_have_ownership_is_the_slice ><a href="#another_data_type_that_doesnt_have_ownership_is_the_slice" class=header-anchor >Another data type that doesn&#39;t have ownership is the <strong>slice</strong>.</a></h2> <p>This type allows for referencing a contiguous sequence of elements in a collection, as opposed to a whole collection.</p> <h3 id=heres_a_small_programming_problem_write_a_function_that_takes_a_string_and_returns_the_first_word_it_finds_in_that_string_if_the_function_doesnt_find_a_space_in_the_string_the_whole_string_must_be_one_word_so_the_entire_string_should_be_returned ><a href="#heres_a_small_programming_problem_write_a_function_that_takes_a_string_and_returns_the_first_word_it_finds_in_that_string_if_the_function_doesnt_find_a_space_in_the_string_the_whole_string_must_be_one_word_so_the_entire_string_should_be_returned" class=header-anchor >Here’s a small programming problem: write a function that takes a string and returns the first word it finds in that string. If the function doesn’t find a space in the string, the whole string must be one word, so the entire string should be returned.</a></h3> <p>Let&#39;s think about the signature of this function:</p> <code>fn first_word&#40;s: &amp;String&#41; -&gt; ?</code> <p>The question is, what should we return? We don&#39;t want the whole string, and we also don&#39;t want to take ownership of it.</p> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class=hljs-type >String</span>) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >usize</span> {
	<span class=hljs-keyword >let</span> <span class=hljs-variable >bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();
    
    <span class="hljs-title function_ invoke__">for</span> (i, &amp;item) <span class=hljs-keyword >in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() {
		<span class=hljs-keyword >if</span> item == <span class=hljs-string >b&#x27; &#x27;</span> {
    		<span class=hljs-keyword >return</span> i;                     
		}                                                
	}
    s.<span class="hljs-title function_ invoke__">len</span>()
}</code></pre> <p>We need to go over the string element by element &#40;nice syntactic sugar on pointer arithmetic guys&#41;, and check values, we convert it to an array of bytes, over which we create an iterator, with <code>iter&#40;&#41;</code>. <code>enumerate</code> wraps the result of <code>iter</code> and returns each element as a tuple instead. The first element is the index, the second a reference to the element.</p> <p>Enumerate returns a tuple, allowing us to use pattern matching to destructure it.</p> <p>We now have a problem: when the value of s.len&#40;&#41; is returned, there&#39;s no meaningful string to use it with- the values are decoupled. We&#39;ll have the value of the length, but the string it came from will be entirely invalidated, as we&#39;re operating on a slice, which has no ownership to pass around to functions, meaning it&#39;s lifetime isn&#39;t extended by moves.</p> <h2 id=string_slices ><a href="#string_slices" class=header-anchor ><strong>String Slices</strong></a></h2> <p>We create these slices using a reference and range, with an inclusive starting index, and an exclusive ending index.</p> <p>Internally, this structure stores the starting index and the length.</p> <p>The type that signifies a <strong>string slice</strong> is written as <code>&amp;str</code>.</p> <p>This will allow us to get back a value that is tied to the data it came from.</p> <p>Remember if we have an <strong>immutable</strong> reference to a thing, we can&#39;t make a mutable reference &#40;within the same scope&#41;.</p> <p>We can also use this type as a parameter, allowing us to use the same function on <code>&amp;String</code> and <code>&amp;str</code> values.</p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Septimia Zenobia. Last modified: March 18, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>