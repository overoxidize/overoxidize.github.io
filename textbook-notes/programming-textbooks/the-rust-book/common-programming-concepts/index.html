<!doctype html> <html lang=en > <link rel=stylesheet  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/default.min.css"> <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/languages/go.min.js"></script> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/tachyons.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Common Programming Concepts</title> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <li><a href="https://github.com/overoxidize">GH</a> <li><a href="/posts/">Posts</a> </ul> </div> <div id=main > <div class=franklin-content > <p><strong>Keywords</strong>: Rust as a set of keywords currently in use, and reserved for future use.</p> <h1 id=variables_and_mutability ><a href="#variables_and_mutability" class=header-anchor >Variables and Mutability:</a></h1> <p>Variables in rust are immutable, but you can make your variables mutable, by adding the <code>mut</code> keyword in front of them.</p> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
    <span class=hljs-keyword >let</span> <span class=hljs-variable >x</span> = <span class=hljs-number >5</span>;
    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;The value of x is: {}&quot;</span>, x);
    x = <span class=hljs-number >6</span>;
    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;The value of x is: {}&quot;</span>, x);
}</code></pre> <p>This code will throw a compile-time error, as x is an immutable variable, and we&#39;ve not used the required keyword to indicate &#40;to the compiler&#41; that we want this valuable to be subject to change over time. </p> <p><code>let mut x &#61; 5</code> will remove the error.</p> <h1 id=variables_vs_constants ><a href="#variables_vs_constants" class=header-anchor >Variables vs Constants:</a></h1> <p>Rust provides a construct for constant variables, via the <code>const</code> keyword. <strong>Note: when using</strong> <code>const</code><strong>the type of the value must be annotated.</strong></p> <h3 id=constants_cannot_be_set_to_a_value_that_can_only_be_computed_at_run-time ><a href="#constants_cannot_be_set_to_a_value_that_can_only_be_computed_at_run-time" class=header-anchor >Constants cannot be set to a value that can only be computed at run-time.</a></h3> <p><code>const MAX_POINTS: u32 &#61; 100_000;</code>.</p> <h1 id=shadowing ><a href="#shadowing" class=header-anchor >Shadowing:</a></h1> <p>When you declare a variable with the same name as a previous variable, the first variable is said to be shadowed by the second, indicating that the second variable&#39;s value is what is seen when the variable is used.</p> <p>Shadowing can be initiated by reusing a variable name with the let keyword.</p> <pre><code class="Rust hljs"><span class=hljs-keyword >let</span> <span class=hljs-variable >x</span> = <span class=hljs-number >5</span>;

<span class=hljs-keyword >let</span> <span class=hljs-variable >x</span> = x * x;</code></pre> <p>Shadowing differs from making a variable mutable, because we&#39;ll get a compile-time error if we try to reassign the variable without using the <code>let</code> keyword.</p> <p>The other difference is that we&#39;re effectively creating a new variable when we use the <code>let</code> keyword, allowing us to change the type of a value but use the same name.</p> <h1 id=data_types ><a href="#data_types" class=header-anchor >Data Types:</a></h1> <h3 id=every_value_in_rust_of_a_certain_data_type ><a href="#every_value_in_rust_of_a_certain_data_type" class=header-anchor >Every value in rust of a certain data type.</a></h3> <h3 id=rust_is_statically_typed_so_it_must_know_the_types_of_all_variables_at_compile_time ><a href="#rust_is_statically_typed_so_it_must_know_the_types_of_all_variables_at_compile_time" class=header-anchor >Rust is statically typed, so it must know the types of all <strong>variables</strong> at compile time.</a></h3> <h2 id=scalar_types ><a href="#scalar_types" class=header-anchor >Scalar Types:</a></h2> <p>A scalar type represent a single value, and in Rust there are: integers, floats, booleans, and chars.</p> <h2 id=unsigned_integers_signed_integers ><a href="#unsigned_integers_signed_integers" class=header-anchor >Unsigned Integers: / Signed Integers:</a></h2> <p>An integer is a whole number, and is associated with the <code>__u32__</code> type. <code>u</code> and <code>i</code> will denote a unsigned or signed integer respectively.</p> <p>The bit size ranges from 8-128, and an additional <code>size</code> for 32/64 bit systems.</p> <p>Floats:</p> <p>Floats are for representing decimals, and come as 32 by default, but have 64 as well.</p> <p>Char:</p> <p>Rust&#39;s char type is 4 bytes, and is unicode, meaning it extends beyond ascii, including emoji, etc.</p> <p>Compound Types:</p> <h3 id=tuples ><a href="#tuples" class=header-anchor >Tuples:</a></h3> <p>A tuple is a way of grouping together values of varied types, and are fixed length structures.</p> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
    <span class=hljs-keyword >let</span> <span class=hljs-variable >tup</span>: (<span class=hljs-type >i32</span>, <span class=hljs-type >f64</span>, <span class=hljs-type >u8</span>) = (<span class=hljs-number >500</span>, <span class=hljs-number >6.4</span>, <span class=hljs-number >1</span>);
}</code></pre> <p>Tuples can be destructured via pattern matching:</p> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
    <span class=hljs-keyword >let</span> <span class=hljs-variable >tup</span> = (<span class=hljs-number >500</span>, <span class=hljs-number >6.4</span>, <span class=hljs-number >1</span>);

    <span class=hljs-keyword >let</span> (x, y, z) = tup;

    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;The value of y is: {}&quot;</span>, y);
}</code></pre> <p>Tuple indexes are accessed via dot notation, and the numerical index, i.e <code>tuple.1</code>.</p> <h3 id=arrays ><a href="#arrays" class=header-anchor >Arrays:</a></h3> <p>Rust arrays must have same type elements, and are fixed length as well.</p> <p>They are useful for allocating data on the stack, rather than the heap.</p> <p>Similar to arrays, are vectors, that can grow or shrink in size.</p> <p>Functions:</p> <p>Rust has a take on expressions vs. statements:</p> <p>Statements are instructions that perform actions, but don&#39;t return values.</p> <p>Expressions evaluate to a value. </p> <p>In some languages, assignments return the value assigned, but this is not true in Rust, so you can&#39;t do <code>let y &#61; &#40;let x &#61; 7&#41;</code>, as <code>let x &#61; 7</code> doesn&#39;t return a value, so there&#39;s nothing to bind y to.</p> <p>If you add a semicolon to the end of an expression, you render it a statement, and thus it won&#39;t return a value.</p> <p>Functions return the value of the final expression in them, or whenever return is encountered.</p> <h1 id=control_flow ><a href="#control_flow" class=header-anchor >Control Flow:</a></h1> <p>Note that you can use if&#39;s in <code>let</code> statements, because they are expressions &#40;they evaluate to a value&#41;.</p> <pre><code class="Rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">main</span>() {
    <span class=hljs-keyword >let</span> <span class=hljs-variable >condition</span> = <span class=hljs-literal >true</span>;
    <span class=hljs-keyword >let</span> <span class=hljs-variable >number</span> = <span class=hljs-keyword >if</span> condition { <span class=hljs-number >5</span> } <span class=hljs-keyword >else</span> { <span class=hljs-number >6</span> };

    <span class=hljs-built_in >println!</span>(<span class=hljs-string >&quot;The value of number is: {}&quot;</span>, number);
}</code></pre> <h2 id=repetition_with_loops ><a href="#repetition_with_loops" class=header-anchor ><strong>Repetition with Loops</strong>:</a></h2> <h2 id=rust_provides_several_loop_constructs_for_executing_code_more_than_once_loop_while_and_for ><a href="#rust_provides_several_loop_constructs_for_executing_code_more_than_once_loop_while_and_for" class=header-anchor >Rust provides several loop constructs for executing code more than once: loop, while, and for.</a></h2> <h2 id=returning_values_from_loops ><a href="#returning_values_from_loops" class=header-anchor ><strong>Returning values from Loops</strong>:</a></h2> <h2 id=loop_is_useful_for_say_retrying_operations_that_might_fail_such_as_checking_whether_a_thread_has_completed_its_job_but_you_might_also_need_to_pass_that_result_to_higher_or_lower_levels_of_abstraction_in_your_code ><a href="#loop_is_useful_for_say_retrying_operations_that_might_fail_such_as_checking_whether_a_thread_has_completed_its_job_but_you_might_also_need_to_pass_that_result_to_higher_or_lower_levels_of_abstraction_in_your_code" class=header-anchor >Loop is useful for, say, retrying operations that might fail, such as checking whether a thread has completed its job, but you might also need to pass that result to higher or lower levels of abstraction in your code.</a></h2> <h2 id=you_can_use_break_followed_by_your_desired_return_value_to_exit_a_loop_and_return_it ><a href="#you_can_use_break_followed_by_your_desired_return_value_to_exit_a_loop_and_return_it" class=header-anchor >You can use <code>break</code> followed by your desired return value, to exit a loop and return it.</a></h2> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Septimia Zenobia. Last modified: April 26, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>